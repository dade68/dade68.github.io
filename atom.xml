<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dade68.github.io</id>
    <title>flowaflow</title>
    <updated>2021-01-02T06:02:30.975Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dade68.github.io"/>
    <link rel="self" href="https://dade68.github.io/atom.xml"/>
    <subtitle>Welcome to my secret park!</subtitle>
    <logo>https://dade68.github.io/images/avatar.png</logo>
    <icon>https://dade68.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, flowaflow</rights>
    <entry>
        <title type="html"><![CDATA[CSAPP lab1]]></title>
        <id>https://dade68.github.io/post/csapp-lab1/</id>
        <link href="https://dade68.github.io/post/csapp-lab1/">
        </link>
        <updated>2020-12-25T08:51:07.000Z</updated>
        <content type="html"><![CDATA[<pre><code>//3
/* 
 * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')
 *   Example: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 15
 *   Rating: 3
 */
int isAsciiDigit(int x) {
    int sign = 0x1&lt;&lt;31;
    int upperBound = ~(sign|0x39);
    int lowerBound = ~0x30;
    upperBound = sign&amp;(upperBound+x)&gt;&gt;31;
    lowerBound = sign&amp;(lowerBound+1+x)&gt;&gt;31;
    return !(upperBound|lowerBound);
}
</code></pre>
<ul>
<li>判断是否大于或小于某个数，这里的做法是通过判断将这个数加到某个数上，最高位是否改变来判断的</li>
</ul>
<pre><code>/* 
 * conditional - same as x ? y : z 
 *   Example: conditional(2,4,5) = 4
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 16
 *   Rating: 3
 */
int conditional(int x, int y, int z) {
    int flag = (~!x) + 1;
    return (flag &amp; z) | (~flag &amp; y);
}
</code></pre>
<ul>
<li>转换为全0和全1</li>
</ul>
<pre><code>/* 
 * isLessOrEqual - if x &lt;= y  then return 1, else return 0 
 *   Example: isLessOrEqual(4,5) = 1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 24
 *   Rating: 3
 */
int isLessOrEqual(int x, int y) {
    int sign = (x &gt;&gt; 31) ^ (y &gt;&gt; 31);
    int a = 0x1 &amp; sign &amp; (x &gt;&gt; 31);
    int b = !sign &amp; !((y + ~x + 1) &gt;&gt; 31);
    return a | b;
}
</code></pre>
<ul>
<li>先判断二者是否同号，同号按正常处理 x + (-y)；异号就看负号或正号在哪边</li>
</ul>
<pre><code>/* 
 * logicalNeg - implement the ! operator, using all of 
 *              the legal operators except !
 *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 4 
 */
int logicalNeg(int x) {
    int a = x &gt;&gt; 31;
    int b = (~x + 1) &gt;&gt; 31;
    return (a | b) + 1;
}
</code></pre>
<ul>
<li>核心在于找0的特点，+0，-0最高位都为0，全1和全0加1就变成了0和1，可以作为返回值</li>
</ul>
<hr>
<h3 id="浮点数">浮点数</h3>
<pre><code>//float
/* 
 * floatScale2 - Return bit-level equivalent of expression 2*f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int's, but
 *   they are to be interpreted as the bit-level representation of
 *   single-precision floating point values.
 *   When argument is NaN, return argument
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned floatScale2(unsigned uf) {
    int sign = uf &gt;&gt; 31;
    int exp = (uf &amp; 0x7f800000) &gt;&gt; 23;
    int frac = uf &amp; 0x7fffff;

    if (exp == 255) {
        return uf;
    } else if (exp == 0) {
        frac &lt;&lt;= 1;
        return sign &lt;&lt; 31 | exp &lt;&lt; 23 | frac;
    } else {
        exp += 1;
        return  sign &lt;&lt; 31 | exp &lt;&lt; 23 | frac;
    }
}
/*
 * floatFloat2Int - Return bit-level equivalent of expression (int) f
 *   for floating point argument f.
 *   Argument is passed as unsigned int, but
 *   it is to be interpreted as the bit-level representation of a
 *   single-precision floating point value.
 *   Anything out of range (including NaN and infinity) should return
 *   0x80000000u.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
int floatFloat2Int(unsigned uf) {
     int sign = (uf &gt;&gt; 31) &amp; 0x1;
     int exp = ((uf &amp; 0x7f800000) &gt;&gt; 23) - 127;
     int frac = uf &amp; 0x7fffff;

     if (exp &lt; 0) return 0;
     else if (exp &gt;= 31) return 0x80000000u;
     else {
         frac = frac | (1 &lt;&lt; 23);
         if (exp &gt; 23) frac &lt;&lt;= (exp - 23);
         else frac &gt;&gt;= (23 - exp);
     }
     if (sign) return -frac;
     else return frac;
}
/* 
 * floatPower2 - Return bit-level equivalent of the expression 2.0^x
 *   (2.0 raised to the power x) for any 32-bit integer x.
 *
 *   The unsigned value that is returned should have the identical bit
 *   representation as the single-precision floating-point number 2.0^x.
 *   If the result is too small to be represented as a denorm, return
 *   0. If too large, return +INF.
 * 
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while 
 *   Max ops: 30 
 *   Rating: 4
 */
unsigned floatPower2(int x) {
    if (x &gt;= 128) return 0xff &lt;&lt;23;
    else if (x &lt; -149) return 0;
    else {
        if (x &gt;= -126) return (x + 127) &lt;&lt; 23;
        else return 1 &lt;&lt; (x + 149);
    }
}
</code></pre>
<ul>
<li><img src="https://dade68.github.io/post-images/1608962095418.jpg" alt="" loading="lazy"></li>
<li><img src="https://dade68.github.io/post-images/1608962109785.jpg" alt="" loading="lazy"></li>
<li><img src="https://dade68.github.io/post-images/1608962144892.jpg" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Head First 设计模式 Chapter6：命令模式--封装调用]]></title>
        <id>https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter6ming-ling-mo-shi-feng-zhuang-diao-yong/</id>
        <link href="https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter6ming-ling-mo-shi-feng-zhuang-diao-yong/">
        </link>
        <updated>2020-12-23T02:58:52.000Z</updated>
        <content type="html"><![CDATA[<p>命令模式：</p>
<blockquote>
<p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p>
</blockquote>
<blockquote>
<p>Nocommand 对象是一个空对象(null object)的例子。当你不想返回一个有意义的的对象时，空对象就很有用。客户也可以将处理 null 的责任转移给空对象。举例来说，遥控器不可能一出厂就设置了有意义的命令对象，所以提供了 NoCommand 对象作为代用品，当调用它的 execute() 方法时，这种对象什么事情都不做。<br>
在许多设计模式中，都会看到空对象的使用。甚至有些时候，空对象本身也被视为是一种设计模式。</p>
</blockquote>
<p>在宏命令中，用命令数组存储一大堆命令。</p>
<p>要点：</p>
<ul>
<li>命令模式将发出请求的对象和执行请求的对象解耦。</li>
<li>在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接受者和一个或一组动作。</li>
<li>调用者通过调用命令对象的 execute() 发出请求，这会使得接受者的动作被调用。</li>
<li>调用者可以接受命令当做参数，甚至在运行时动态地进行。</li>
<li>命令可以支持撤销，做法是实现一个 undo() 方法来回到 execute() 被执行前的状态。</li>
<li>宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销。</li>
<li>实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接受者。</li>
<li>命令也可以用来实现日志和事务系统。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Head First 设计模式 Chapter5：单件模式（Singleton Pattern）]]></title>
        <id>https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter5dan-jian-mo-shi-singleton-pattern/</id>
        <link href="https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter5dan-jian-mo-shi-singleton-pattern/">
        </link>
        <updated>2020-12-22T11:17:22.000Z</updated>
        <content type="html"><![CDATA[<pre><code>public class Singleton {
    private static Singleton uniqueInstance;
    // 这里有其他的有用实例化变量
    private Singleton() { }
    public static Singleton getInstance () {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
    // 这里是其他的有用方法
}
</code></pre>
<p>单件模式：</p>
<blockquote>
<p>确保一个类只有一个实例，并提供一个全局访问点。</p>
</blockquote>
<ul>
<li>我们正在把某个类设计成自己管理的一个单独实例，同时也避免其他类再自行产生实例。要想取得单间实例，通过单件类是唯一的途径。</li>
<li>我们也提供对这个实例的全局访问点：当你需要实例时，向类查询，它会返回单个实例。前面的例子利用延迟实例化的方式创建单件，这种做法对资源敏感的对象特别重要。</li>
</ul>
<p>多线程创建实例问题解决办法：</p>
<ol>
<li>同步 getInstance() 方法</li>
<li>急切实例化</li>
<li>双重检查加锁</li>
</ol>
<p><strong>双重检查加锁</strong></p>
<pre><code>public class Singleton {
    private volatile static Singleton uniqueInstance;
    // 这里有其他的有用实例化变量
    private Singleton() { }
    public static Singleton getInstance () {
        if (uniqueInstance == null) {
            synchronized(Singleton.class) {
                if (uniqueInstance == null) {
                     uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
    // 这里是其他的有用方法
}
</code></pre>
<p>要点：</p>
<ul>
<li>单件模式确保程序中一个类最多只有一个实例。</li>
<li>单件模式也提供访问这个实例的全局点。</li>
<li>在 Java 中实现单件模式需要私有的构造器、一个静态方法和一个静态变量。</li>
<li>确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，以解决多线程的问题（我们必须认定所有的程序都是多线程的）。</li>
<li>小心，你如果使用多个类加载器，可能导致单件失效而产生多个实例。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Head First 设计模式 Chapter 4：工厂模式]]></title>
        <id>https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter-4gong-han-mo-shi/</id>
        <link href="https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter-4gong-han-mo-shi/">
        </link>
        <updated>2020-12-21T07:12:31.000Z</updated>
        <content type="html"><![CDATA[<p>工厂（factory）处理创建对象的细节。</p>
<p><strong>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了</strong></p>
<p><code>abstract Product factoryMethod(string type)</code></p>
<p>工厂方法模式：</p>
<blockquote>
<p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>
</blockquote>
<p>依赖倒置原则（Dependency Inversion Principle）:</p>
<blockquote>
<p>要依赖抽象，不要依赖具体类</p>
</blockquote>
<p>这个原则说明了：不能让高层组件依赖底层组件，而且，不敢高层或底层组件，“两者”都应该依赖于抽象。<br>
在依赖倒置原则中的倒置指的是和一般OO设计的思考方式完全相反。<br>
使用中的的指导方针：</p>
<ul>
<li>变量不可以持有具体类的应用。（如果使用 new，就会持有具体类的应用，你可以改用工厂来避开这样的做法。）</li>
<li>不要让类派生自具体类。（请派生自一个抽象—接口或抽象类。）</li>
<li>不要覆盖基类中已实现的方法。</li>
</ul>
<p>抽象工厂模式：</p>
<blockquote>
<p>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
</blockquote>
<p>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。</p>
<p>要点：</p>
<ul>
<li>所有的工厂都是用来封装对象的创建。</li>
<li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦。</li>
<li>工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。</li>
<li>抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露的方法中。</li>
<li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。</li>
<li>工厂方法允许类将实例化延迟到子类进行。</li>
<li>抽象工厂创建相关的对象家族，而不需要依赖它们的实现类。</li>
<li>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。</li>
<li>工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体类编程。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Head First 设计模式 Chapter 3：装饰者模式]]></title>
        <id>https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter-3zhuang-shi-zhe-mo-shi/</id>
        <link href="https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter-3zhuang-shi-zhe-mo-shi/">
        </link>
        <updated>2020-12-21T01:58:36.000Z</updated>
        <content type="html"><![CDATA[<p>开放-关闭原则</p>
<ul>
<li>类应该对扩展开放，对修改关闭</li>
</ul>
<p>我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。</p>
<p>在选择需要被扩展的代码部分时要小心。每个部分都采用开放-关闭原则，是一种浪费，也没必要，还会导致代码变得复杂且难以理解。</p>
<p>OO模式</p>
<ul>
<li>装饰者模式——动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。</li>
</ul>
<p>要点：</p>
<ul>
<li>继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。</li>
<li>在我们的设计中，应该允许行为可以被扩展，而无需修改现有的的代码。</li>
<li>组合和委托可用于在运行时动态地加上新的行为。</li>
<li>除了继承，装饰者模式也可以让我们扩展行为。</li>
<li><strong>装饰者模式意味着一群装饰者类，这些类用来包装具体组件。</strong></li>
<li><strong>装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型都经过接口或者继承实现）。</strong></li>
<li><strong>装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。</strong></li>
<li>你可以用无数个装饰者包装一个组件。</li>
<li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。</li>
<li>装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li>
</ul>
<p><s><em>装饰者类和被装饰者类具有相同的类型，可以使得装饰者继续嵌套装饰。</em></s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSAPP Chapter 11：网络编程]]></title>
        <id>https://dade68.github.io/post/csapp-chapter-11wang-luo-bian-cheng/</id>
        <link href="https://dade68.github.io/post/csapp-chapter-11wang-luo-bian-cheng/">
        </link>
        <updated>2020-12-20T12:08:33.000Z</updated>
        <content type="html"><![CDATA[<p>每个网络应用都是基于客户端-服务器模型的。根据这个模型，一个应用是由一个服务器和一个或多个客服端组成的。服务器管理资源，以某种方式操作资源，为它的客户端提供服务。客服端-服务器模型中的基本操作是客服端-服务器事务，它是由客户端请求和跟随其后的服务器响应组成的。</p>
<p>客户端和服务器通过因特网这个全球网络来通信。从程序员的观点来看，我们可以把因特网看成是一个全球范围的主机集合，具有以下几个属性: 1)每个因特网主机都有一个唯一的32位名字，称为它的 IP 地址。 2） IP 地址的集合被映射为一个因特网域名的集合。 3）不同因特网主机上的进程能够通过连接互相通信。</p>
<p>客服端和服务器通过使用套接字接口建立连接。一个套接字是连接的一个端点，连接以文件描述符的形式提供给应用程序。套接字接口提供了打开和关闭套接字描述符的函数。客服端和服务器通过读写这些描述符来实现彼此间的通信。</p>
<p>Web 服务器使用 HTTP 协议和它们的客户端(例如浏览器)彼此通信。浏览器向服务器请求静态或者动态的内容。对静态内容的请求是通过从服务器磁盘取得文件并把它返回给客户端来服务的。对动态内容的请求是通过在服务器上一个子进程的上下文中运行一个程序并将它的输出返回给客户端来服务的。CGI 标准提供了一组规则，来管理客户端如何将程序参数传递给服务器，服务器如何将这些参数以及其他信息传递给子进程，以及子进程如何将它的输出发送回客户端。只用几百行 C 代码就能实现一个简单但是有功效的 Web 服务器，它既可以提供静态内容，也可以提供动态内容。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSAPP Chapter 12：并发编程]]></title>
        <id>https://dade68.github.io/post/csapp-chapter-12bing-fa-bian-cheng/</id>
        <link href="https://dade68.github.io/post/csapp-chapter-12bing-fa-bian-cheng/">
        </link>
        <updated>2020-12-20T11:27:51.000Z</updated>
        <content type="html"><![CDATA[<p>一个并发程序是由在时间上重叠的一组逻辑流组成的。这一章中讲述了三种不同的构建并发程序的机制：进程、I/O多路复用和线程。</p>
<p>进程是由内核自动调度的，而且因为它们有各自独立的虚拟地址空间，所以要实现共享数据，必须要有显示地IPC机制。事件驱动程序创建它们自己的并发逻辑流，这些逻辑流被模型化为状态机，用 I/O 多路复用来显示地调度这些流。因为程序运行在一个单一进程中，所以在流之间共享数据速度很快而且很容易。线程是这些方法的混合。同基于进程的流一样，线程也是由内核自动调度的。同基于 I/O 多路复用的流一样，线程是运行在一个单一进程的上下文中的，因此可以快速而方便地共享数据。</p>
<p>无论哪种并发机制，同步对共享数据的并发访问都是一个困难的问题。提出对信号量的 P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者-消费者成熟中有限缓冲区和读者-写者系统中的共享对象这样的资源访问进行调度。一个并发预线程化的 echo 服务器提供了信号量使用场景的很好地例子。</p>
<p>并发也引入了其他的一些困难的问题。被线程调用函数必须具有一种称为线程安全的属性。本章定义了四类线程不安全的函数，以及一些将它们变为线程安全的建议。可重入函数是线程安全函数的一个真子集，它不访问任何共享数据。可重入函数通常比不可重入函数更为有效，因为它们不需要任何同步原语。竞争和死锁是并发程序中出现的另一些困难的问题。当程序员错误地假设逻辑流该如何调度时，就会发生竞争。当一个流等待一个永远都不会发生的事件时，就会发生死锁。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSAPP Chapter 10: 系统级I/O]]></title>
        <id>https://dade68.github.io/post/csapp-chapter-10-xi-tong-ji-io/</id>
        <link href="https://dade68.github.io/post/csapp-chapter-10-xi-tong-ji-io/">
        </link>
        <updated>2020-12-17T08:07:44.000Z</updated>
        <content type="html"><![CDATA[<p>输入/输出 (I/O)是在主存和外部设备 (例如磁盘驱动器、终端和网络)之间复制数据的过程。输入操作是从 I/O 设备复制数据到主存，而输出操作是从主存复制数据到 I/O 设备。<br>
所有语言的运行时系统都提供执行 I/O 的较高级别的工具。例如，ANSI C 提供标准 I/O 库，包含像 printf 和 scanf 这样执行带缓冲区 I/O 函数。C++ 语言用它的重载操作符 &lt;&lt; (输入) 和 &gt;&gt; (输出) 提供了类似的功能。在 Linux 系统中，是通过使用由内核提供的系统级 Unix I/O 函数来实现这些较高级别 I/O 函数的。大多数时候，高级别 I/O 函数工作量好，没有必要直接使用 Unix I/O。</p>
<h1 id="unix-io">Unix I/O</h1>
<p>一个 Linux 文件就是一个 <em>m</em> 个字节的序列：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub><mi mathvariant="normal">，</mi><msub><mi>B</mi><mn>1</mn></msub><mi mathvariant="normal">，</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>B</mi><mi>k</mi></msub><mi mathvariant="normal">，</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>B</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">B_{0}，B_{1}，...,  B_{k}，...,  B_{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><br>
所有的 I/O 设备 (例如网络、磁盘和终端) 都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅的映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ul>
<li>打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它将要访问一个 I/O 设备。内核返回一个非负整数，叫做描述符，它在后续对此文件的所有操作中标示这个文件。内核纪录有关这个打开文件所有信息。应用程序只需记住这个描述符。
<blockquote>
<p>每个进程都有它独立的描述符表 (descriptor table)。而所有的进程共享一张文件表 (file tabel)和一张 v-node表 (v-node table)。</p>
</blockquote>
</li>
<li>Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入 (描述符为0)、标准输出 (描述符为1)和标准错误 (描述符为2)。头文件 &lt;unistd.h&gt; 定义了常量 STDIN_FILENO、STDOUT_FILENO 和 STDERR_FILENO，它们可用来代替显示的描述符值。</li>
<li>改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置 <em>k</em> ，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行 seek 操作，显示地设置文件的当前位置为 <em>k</em>。</li>
<li>读写文件。一个读操作就是从文件复制 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 个字节到内存，从当前文件位置 <em>k</em> 开始，然后将 <em>k</em> 增加到 <em>k+n</em>。给定一个大小为 <em>m</em> 字节的文件，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">k&gt;=m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 时执行读操作会触发一个称为 end-of-file (EOF) 的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF”符号。类似的，写操作就是从内存复制 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 个字节到一个文件夹，从当前文件位置 <em>k</em> 开始，然后更新 <em>k</em>。</li>
<li>关闭文件。当应用完成了对文件的访问以后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Head First 设计模式 Chapter 2：观察值(Observer)模式]]></title>
        <id>https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter-2guan-cha-zhi-observermo-shi/</id>
        <link href="https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter-2guan-cha-zhi-observermo-shi/">
        </link>
        <updated>2020-12-15T08:26:13.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>观察者模式定义了对象之间一对多的关系。</li>
<li>主题(也就是可观察者)用一个共同的接口来更新观察者。</li>
<li>观察者和可观察者之间用松耦合方式组合(loosecoupling)，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li>
<li>使用此模式时，你可从被观察者处推(push)或拉(pull)数据(然而，推的方式被认为更“正确”)。</li>
<li>有多个观察者时，不可以依赖特定的通知顺序。</li>
<li>Java有多种观察者模式的实现，包括了通用的java.util.Observable。</li>
<li>要注意java.util.Observable实现上所带来的一些问题。</li>
<li>如果有必要的话，可以实现自己的Observable，这并不难，不要害怕。</li>
<li>Swing大量使用观察者模式，许多GUI框架也是如此。</li>
<li>此模式也被应用在许多地方，例如：JavaBeans、RMI。</li>
</ul>
<h1 id="oo原则">OO原则</h1>
<ol>
<li>封装变化</li>
<li>多用组合，少用继承</li>
<li>针对接口编程，不针对实现编程</li>
<li>为交互对象之间的松耦合设计而努力。</li>
</ol>
<h1 id="oo模式">OO模式</h1>
<p>观察者模式——在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Head First 设计模式 Chapter 1:设计模式入门]]></title>
        <id>https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter-1she-ji-mo-shi-ru-men/</id>
        <link href="https://dade68.github.io/post/head-first-she-ji-mo-shi-chapter-1she-ji-mo-shi-ru-men/">
        </link>
        <updated>2020-12-15T08:06:01.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>良好的OO设计必须具备可复用、可扩充、可维护三个特性。</li>
<li>模式可以让我们建造处具有良好OO设计质量的系统。</li>
<li>模式被认为是历经验证的OO设计经验。</li>
<li>模式不是代码，而是针对设计问题的通用解决方案。你可把它们应用到特定的应用中。</li>
<li>模式不是被发明，而是被发现。</li>
<li>大多数的模式和原则，都着眼于软件变化的主题。</li>
<li>大多数的模式都允许系统局部改变独立于其他部分。</li>
<li>我们常把系统中会变化的部分抽出来封装。</li>
<li>模式让开发人员之间有共享的语言，能够最大化沟通的价值。</li>
</ul>
<h1 id="oo原则">OO原则</h1>
<ol>
<li>封装变化</li>
<li>多用组合，少用继承</li>
<li>针对接口编程，不针对实现编程</li>
</ol>
<h1 id="oo模式">OO模式</h1>
<p>策略模式——定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
]]></content>
    </entry>
</feed>